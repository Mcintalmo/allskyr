{
    "collab_server" : "",
    "contents" : "#Returns the norm of the given vector \nnorm <- function(vector){\n  if(class(vector) == \"list\"){\n    return(sapply(vector, function(vector){return(sqrt(sum(vector ^ 2)))}))\n  }\n  else if (class(vector) == \"numeric\"){\n    return(sqrt(sum(vector ^ 2)))\n  }\n  else {\n    stop(\"Invalid object passed to norm\")\n  }\n}\n\n#Returns the normalized vector\nnormalize <- function(vector){\n  if(class(vector) == \"list\"){\n    sapply(vector, function(vector){return(vector / norm(vector))})\n  }\n  else if(class(vector) == \"numeric\"){\n    return(vector / norm(vector))\n  }\n  else {\n    stop(\"Invalid object passed to normalize\")\n  }\n}\n\n#Returns the cross product of two vectors\ncross.product <- function(vector1, vector2){\n  if((length(vector1) != 3) || (length(vector2) != 3)){\n    stop(\"Invalid dimensions for cross product (D[3] X D[3])\")\n  }\n  \n  i = vector1[[2]] * vector2[[3]] - vector1[[3]] * vector2[[2]]\n  j = vector1[[3]] * vector2[[1]] - vector1[[1]] * vector2[[3]]\n  k = vector1[[1]] * vector2[[2]] - vector1[[2]] * vector2[[1]]\n  \n  return(c(i, j, k))\n}\n\n#Converts from equatorial coordinates to cartesian coordinates\nequatorial.to.cartesian <- function(ra, dec=NULL){\n  #If the data is being passed as a table, break it into two vectors\n  if((length(dec) == 0) && (length(ra) == 2)){\n    dec <- sapply(ra, function(ra){return(ra[2])})\n    ra  <- sapply(ra, function(ra){return(ra[1])})\n  } \n  #If the ha is provided, break it off\n  else if(all(names(ra) == c(\"ra\", \"dec\", \"ha\"))) {\n    dec <- ra$dec\n    ha <- ra$ha\n    ra <- ra$ra\n  }\n  #Null case\n  else if((length(ra) == 0) && (length(dec)) == 0){\n    return(c(0, 0, 0))\n  }\n  else if(length(ra) != length(dec)){\n    stop(\"Invalid length of ra or dec. Haulting execution.\")\n  }\n  \n  r <- lapply(1:length(ra), function(i, ra, dec){\n    x = cos(dec[[i]] * pi / 180) * cos(ra[[i]] * pi / 180)\n    y = cos(dec[[i]] * pi / 180) * sin(ra[[i]] * pi / 180)\n    z = sin(dec[[i]] * pi / 180)\n    return(c(x, y, z))\n  }, ra, dec)\n  \n  return(r)\n}\n\n#event.start.end <- function(events){\n#  event.positions <- sapply(events, function(event){\n#    r.start <- equatorial.to.cartesian(event.start.equatorial(event))\n#    r.end <- equatorial.to.cartesian(event.start.equatorial(event))\n#    \n#    r.start.end <- list(c(r.start, r.end))\n#    names(r.start.end) <- event.name(event)\n#    return(r.start.end)\n#  })\n#  return(event.positions)\n#}\n\n\n#currently only calculates the radiant of two given events.\n#need an optimized way to calculating radiant for more than two events\nradiant <- function(event1, event2){\n  \n  r1 <- equatorial.to.cartesian(event.equatorial(event1))\n  r1.start <- r1[[1]]\n  r1.end <- r1[[event.num_fr(event1)]]\n  \n  r2 <- equatorial.to.cartesian(event.equatorial(event2))\n  r2.start <- r2[[1]]\n  r2.end <- r2[[event.num_fr(event2)]]\n  \n  n1 <- cross.product(r1.start, r1.end)\n  n2 <- cross.product(r2.start, r2.end)\n  \n  rad <- normalize(cross.product(n1, n2))\n  \n  rpos <- norm(r1.start - rad) + norm(r2.start - rad)\n  rneg <- norm(r1.start + rad) + norm(r2.start + rad)\n  \n  if(is.na(rneg) | is.na(rpos) | is.null(rneg) | is.null(rpos)){\n    stop(event.name(event1), \"\\n\", event.name(event2))\n  }\n  \n  if(rneg < rpos){\n    rad <- -rad\n  }\n  \n  x <- rad[[1]]\n  y <- rad[[2]]\n  z <- rad[[3]]\n  \n  rho <- norm(c(x, y))\n  rad.ra <- (acos(x / rho) * 180 / pi) %% 360\n  \n  if(y < 0){\n    rad.ra <- 360 - rad.ra\n  }\n  \n  rho <- norm(rad)\n  rad.dec <- asin(z / rho) * 180 / pi\n  \n  return(c(rad.ra, rad.dec))\n}\n\n#Input list of events\n#Take first two\n#Find radiant \n#shift second event into the first event\n#Get next event\n\n#output list of radiants",
    "created" : 1511916355819.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4261429534",
    "id" : "194228D",
    "lastKnownWriteTime" : 1513044404,
    "last_content_update" : 1513044404868,
    "path" : "E:/Alex/Documents/GitHub/allskyr/radiant.R",
    "project_path" : "radiant.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}